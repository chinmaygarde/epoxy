{#
  This source file is part of Epoxy licensed under the MIT License.
  See LICENSE.md file for details.
#}

// THIS FILE IS GENERATED BY THE EPOXY FFI BINDIGS GENERATOR VERSION {{epoxy_version}}.


import 'dart:ffi' as ffi;

{% for ns in namespaces %}

{#
  Enum definitions.
#}

{% for enum in ns.enums %}
enum {{ enum.name }} {
{% for member in enum.members %}
  {{ member }},
{% endfor %}
} //  {{ enum.name }}

{% endfor %}

{#
   Struct Definitions.
#}

{% for struct in ns.structs %}
class {{ struct.name }} extends ffi.Struct {
{% for var in struct.variables %}

{% if var.is_enum %}
  @ffi.Uint64()
  int enum_raw_{{var.identifier}};

  {{var.type}} get {{var.identifier}} => {{var.type}}.values[enum_raw_{{var.identifier}}];

  void set {{var.identifier}}({{var.type}} val) => enum_raw_{{var.identifier}} = val.index;
{% else if var.is_struct %}
  ffi.Pointer<{{var.type}}> {{var.identifier}};
{% else if var.is_pointer %}
  ffi.Pointer<ffi.{{dart_ffi_type(var.type)}}> {{var.identifier}};
{% else %}
  @ffi.{{dart_ffi_type(var.type)}}()
  {{dart_type(var.type)}} {{var.identifier}};
{% endif %}
{% endfor %}

} //  struct {{ struct.name }}

{% endfor %}
{#
   Function Definitions.
#}

{# Typedef for the native function #}
{% for func in ns.functions %}
typedef {{func.name}}CType =
{% if func.returns_enum %}
  ffi.Uint64
{% else if func.returns_struct %}
  ffi.Pointer<{{func.return_type}}>
{% else %}
  {% if func.pointer_return %}
  ffi.Pointer<ffi.{{dart_ffi_type(func.return_type)}}>
  {% else %}
  ffi.{{dart_ffi_type(func.return_type)}}
  {% endif %}
{% endif %}
Function(
{% for arg in func.arguments%}
{% if arg.is_enum %}
ffi.Uint64
{% else if arg.is_struct %}
ffi.Pointer<{{arg.type}}>
{% else if arg.is_pointer %}
ffi.Pointer<ffi.{{dart_ffi_type(arg.type)}}>
{% else %}
ffi.{{dart_ffi_type(arg.type)}}
{% endif %}
{{arg.identifier}}{% if not loop.is_last %},{% endif %}
{% endfor %}
);

{# Typedef for the Desugared Dart function #}
typedef {{func.name}}DesugaredDartType =
{% if func.returns_enum %}
  int
{% else if func.returns_struct%}
  ffi.Pointer<{{func.return_type}}>
{% else %}
  {% if func.pointer_return %}
  ffi.Pointer<ffi.{{dart_ffi_type(func.return_type)}}>
  {% else %}
  {{dart_type(func.return_type)}}
  {% endif %}
{% endif %}
Function(
{% for arg in func.arguments %}
{% if arg.is_enum %}
  int
{% else if arg.is_struct %}
  ffi.Pointer<{{arg.type}}>
{% else if arg.is_pointer %}
  ffi.Pointer<ffi.{{dart_ffi_type(arg.type)}}>
{% else %}
  {{dart_type(arg.type)}}
{% endif %}
{{arg.identifier}}
{% if not loop.is_last %},{% endif %}
{% endfor %}
);
{{func.name}}DesugaredDartType _{{func.name}}Desugared;

{# Generate the function that calls the desugared Dart function. For now, only enums are desugared. #}
{% if func.returns_enum %}
  {{ func.return_type }}
{% else if func.returns_struct %}
  ffi.Pointer<{{ func.return_type }}>
{% else %}
  {% if func.pointer_return %}
  ffi.Pointer<ffi.{{dart_ffi_type(func.return_type)}}>
  {% else %}
  {{dart_type(func.return_type)}}
  {% endif %}
{% endif %}
 {{func.name}}(
{% for arg in func.arguments %}
{% if arg.is_enum %}
{{arg.type}}
{% else if arg.is_struct %}
ffi.Pointer<{{arg.type}}>
{% else if arg.is_pointer %}
ffi.Pointer<ffi.{{dart_ffi_type(arg.type)}}>
{% else %}
{{dart_type(arg.type)}}
{% endif %}
{{arg.identifier}} {% if not loop.is_last %},{% endif %}
{% endfor %}
) {
  return
{% if func.returns_enum %}
{{func.return_type}}.values[
{% endif %}
 _{{func.name}}Desugared(
{% for arg in func.arguments %}
{% if arg.is_enum %}
{{arg.identifier}}.index
{% else %}
{{arg.identifier}}
{% endif %}
{% if not loop.is_last %},{% endif %}
{% endfor %}
)
{% if func.returns_enum %}
]
{% endif %}
;
}

{% endfor %}

{#
   Dylib Binding Routine.
#}
// This method must be called once upfront before using any of the methods in the {{ns.name}} namespace.
void AttachNativeBindings() {
  // Open the {{ns.name}} dylib to look for native functions.
  final dylib = ffi.DynamicLibrary.open("example/{{ns.name}}.dll");

  {# Bind standalone functions. #}
  // Bind standalone functions
  {% for func in ns.functions %}
  _{{func.name}}Desugared = dylib.lookup<ffi.NativeFunction<{{func.name}}CType>>("EPOXY_BIND_{{func.name}}").asFunction();
  {% endfor %}
}

{% endfor %}
